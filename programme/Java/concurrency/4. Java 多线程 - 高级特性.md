# Java 多线程 - 高级特性

## 一. 显示锁 与 隐式锁(内置锁)

协调对共享对象的访问机制有: synchronized、volatile、ReentrantLock

### 1. Lock 与 ReentrantLock (显示锁)

``` java
1) Lock 接口中定义了一种无条件、可轮询的、定时的以及可中断的锁获取操作，所有加锁和解锁的方法都是显式的
    public interfece Lock {
        void lock();
        void lockInterruptibly() throws InterruptedException;
        boolean tryLock();
        boolean tryLock(long timeout, TimeUnit unit 
            throw InterruptedException;
        void unlock();
        Condition newCondition();
    }

2) ReentrantLock 实现了 Lock 接口, 并提供了与 synchronized 相同的互斥性和内存可见性
    // 使用 ReentrantLock 保护对象状态
    Lock lock = new ReentrantLock();
    ...
    lock.lock();
    try {
        // 更新对象状态
        // 捕获异常，并在必要时恢复不变性条件
    } finally {
        // 一定要记得在 finally 块里释放锁
        lock.unlock();
    }
    
    注意：在使用 ReentrantLock 时，一定要有释放锁的操作。
          ReentrantLock 不能完全替代 synchronized 的原因: 当程序执行控制离开被保护的代码块时，不会自动清除锁。因为人可能会忘记。
```

- 轮询锁与定时锁

``` java
1) 轮询锁和定时锁可由tryLock来实现

2) 轮询锁，定时锁可以避免死锁的发生

3) 轮询锁通过释放已获得的锁，并退回重新尝试获取所有锁（lock.tryLock()），定时锁通过释放已获得的锁，放弃本次操作（lock.tryLock(timeout, unit)）来避免死锁

4) 轮询锁: 通过 tryLock 来避免锁顺序死锁
while (true) {
            if (fromAcct.lock.tryLock()) {
                try {
                    if (toAcct.lock.tryLock()) {
                        try {
                            if (fromAcct.getBalance().compareTo(amount) < 0)
                                throw new InsufficientFundsException();
                            else {
                                fromAcct.debit(amount);
                                toAcct.credit(amount);
                                return true;
                            }
                        } finally {
                            toAcct.lock.unlock();
                        }
                    }
                } finally {
                    fromAcct.lock.unlock();
                }
            }
            if (System.nanoTime() < stopTime)
                return false;
            NANOSECONDS.sleep(fixedDelay + rnd.nextLong() % randMod);
        }
    }

5) 定时锁: 带有时间限制的加锁
public boolean trySendOnSharedLine(String message,
                                       long timeout, TimeUnit unit)
            throws InterruptedException {
        long nanosToLock = unit.toNanos(timeout)
                - estimatedNanosToSend(message);
        if (!lock.tryLock(nanosToLock, NANOSECONDS))
            return false;
        try {
            return sendOnSharedLine(message);
        } finally {
            lock.unlock();
        }
    }
```

- 可中断的锁获取操作

``` doc
1) Lock.lockInterruptibly()：该锁与lock相似，但可以被中断

2) 如果线程未被中断，也不能获取到锁，就会一直阻塞下去，直到获取到锁或发生中断请求

3) 定时的 lock.tryLock(timeout, unit) 同样能响应中断
```

- 非块结构加锁

``` doc
1) 内置锁是基于块结构的加锁

2) Lock 可以使块与块交叉实现非块结构的加锁（连锁式加锁或者锁耦合），例：链表中，next 节点加锁后，释放 pre 节点的锁
```


### 2. ReentrantLock - 性能考虑因素

``` doc
1) 竞争性能是可伸缩性的关键因素：如果有越多的资源被耗费在锁的管理和调度上，那么应用程序得到的资源就越少

2) 在 Java5.0 中，ReentrantLock 能提供更高的吞吐量，但在 Java6 中，二者的吞吐量非常接近
```


### 3. ReentrantLock - 公平锁与非公平锁

``` doc
1) ReentrantLock 构造函数中提供两种公平性选择

2) 公平锁与非公平锁
  Lock fairLock = new ReentrantLock(true);  // 公平锁
  
  a) 在公平的锁上，线程将按照它们发出请求的顺序来获得锁
  b) 在非公平的锁上，则允许”插队“：当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过队列中所有的等待线程并获得这个锁
  c) 公平性将由于在挂起线程和恢复线程时存在的开销而极大地降低性能（非公平性的锁允许线程在其他线程的恢复阶段进入加锁代码块）
  d) 当持有锁的时间相对较长，或者请求锁的平局时间间隔较长，那么应该使用公平锁
  e) 内置锁默认为非公平锁
```


### 4. ReentrantLock(显示锁) 与 synchronized 隐式锁(内置锁) 之间进行选择

``` doc
1) 在内置锁 synchronized 无法满足需求的情况下，ReentrantLock 可以作为一种高级工具。当需要一些高级功能时才应该使用 ReentrantLock，这些功能包括：可定时的、可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁。否则，还是应该优先使用 synchronized

2) 两种所不要混合使用
```


### 5. ReentrantLock 读 - 写锁

``` doc
1) ReentrantLock 实现了一种标准的互斥锁: 每次最多只有一个线程能持有 ReentrantLock.

 a) 写-写: 互斥
 b) 写-读: 互斥
 
2) 读写锁的可选实现：
 a) 释放优先。写入锁释放后，应该优先选择读线程，写线程，还是最先发出请求的线程
 b) 读线程插队。锁由读线程持有，写线程再等待，再来一个读线程，是继续让读线程访问，还是让写线程访问
 c) 重入性。读取锁和写入锁是否可重入
 d) 降级。将写入锁降级为读取锁
 e) 升级。将读取锁升级为写入锁

3) 在非公平的锁中，线程获得访问许可的顺序是不确定的。写线程降级为读线程是可以的，当从读线程升级为写线程这是不可以的（这样会导致死锁）
```


### 6. ReentrantReadWriteLock

``` java
1) 读写锁的机制： 
  a) 读-读不互斥，读线程可以并发执行； 
  b) 读-写互斥，有写线程时，读线程会堵塞； 
  c) 写-写互斥，写线程都是互斥的。


2) ReentrantReadWriteLock 和 ReentrantLock 的比较： 
  ReentrantReadWriteLock 是对 ReentrantLock 的复杂扩展，能适合更加复杂的业务场景，ReentrantReadWriteLock 可以实现一个方法中读写分离的锁的机制。而 ReentrantLock 只是加锁解锁一种机制。

2) 示例
//创建ReentrantReadWriteLock对象
    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

    //抽取读写锁
    private Lock readLock = rwl.readLock();
    private Lock writeLock = rwl.writeLock();
    public int getXXX(){
        readLock.lock();
        try{
            //执行操作
        }finally{
            readLock.unlock();
        }
    }
    public void setXXX(){
        writeLock.lock();
        try{
            //执行操作
        }finally{
            writeLock.unlock();
        }
    }
```

### 6. 对比

``` doc
1) Synchronized 是在 JVM 层面上实现的，无需显示的加解锁，而 ReentrantLock 和 ReentrantReadWriteLock 需显示的加解锁，一定要保证锁资源被释放

2) Synchronized 是针对一个对象的，而 ReentrantLock 和 ReentrantReadWriteLock 是代码块层面的锁定

3) ReentrantReadWriteLock 引入了读写和并发机制，可以实现更复杂的锁机制，并发性相对于 ReentrantLock 和 Synchronized 更高
```

## 二. 构建自定义同步工具

### 1. 状态依赖性管理

### 2. 使用条件队列

### 3. 显示 Condition 对象

### 4. Synchronizer 

### 5. AbstractQueuedSynchronizer

### 6. java.util.concurrent 同步类中的 AQS

``` doc
AQS
```


## 三. 原子变量与非阻塞同步机制

### 1. 锁的劣势


### 2. 硬件对并发的支持


### 3. 原子变量类


### 4. 非阻塞算法


## 四. Java 内存模型

### 1. 内存模型

``` doc
JMM 
```

- 平台的内存模型
- 重排序
- Java 内存模型介绍

``` doc
1) Happens-Before 规则

程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；
volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；


偏序关系

全序关系


```

- 借助同步


### 2. 发布

- 不安全的发布
- 安全的发布
- 安全初始化模式
- 双重检查锁


### 3. 初始化过程中的安全性
