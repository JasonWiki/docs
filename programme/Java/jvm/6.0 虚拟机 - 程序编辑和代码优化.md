# 程序编辑和代码优化

## 一. 早期(编译期) 优化

``` doc
前端编译器: 把.java转变为.class的过程, 如 Sun 的 Javac、Eclipse JDT 中的增量式编译器(ECJ)

JIT 编译器: 把字节码转变为机器码的过程, 如 HotSpot VM 的 C1、C2 编译器

AOT 编译器: 静态提前编译器，直接将*.java文件编译本地机器代码的过程, 如 GNU Compiler for the Java(GCJ)、Excelsior JET
```

### 1. Javac 编译器

- Javac 的源码和调试

``` doc
javac 的源码存放在 JDK_SRC_HOME/langtools/src/share/slasses/com/sun/tools/javac 中, 编译过程大致可以分为3个过程：
  a) 解析与填充符号表过程。
  b) 插入式注解处理器的注解处理过程。
  c) 分析与字节码生成过程。
```

- 解析与填充符号表过程

``` doc
1) 词法分析与语法分析
  a) 词法分析：将源代码的字符流转变为标记（Token）集合，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记，在Javac的源码中，词法分析过程由 com.sun.tools.javac.parser.Scanner 类来实现。

  b) 语法分析: 根据Token序列构造抽象语法树的过程，抽象语法树是一种用来描述程序代码语法结构的树形表述方式。语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、接口、返回值甚至代码注释都可以是一个语法结构。语法分析过程由com.sun.tools.javac.parser.Parser类实现，这个阶段产出的抽象语法树由com.sun.tools.javac.tree.JCTree类表示，经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都是建立在抽象语法树之上的。

2) 填充符号表
  完成抽象语法树之后，下一步就是填充符号表的过程，即 enterTrees() 方法。符号表是由一组符号地址和符号信息构成的表格，类似于哈希表中K-V值对的形式。符号表中所登记的信息在编译的不同阶段都要用到。当对符号名进行地址分配时，符号表是地址分配的依据。填充过程由com.sun.tools.javac.comp.Enter类实现。
```

- 注解处理器

``` doc
1) JDK 1.5 之后，Java 提供了对注解的支持，这些注解与普通的 Java 代码一样，在运行期间发挥作用。

2) JDK 1.6 中实现了 JSR-269 规范, 提供了一组插入式注解处理器的标准 API 在编译期间对注解进行处理, 这是一组编译器的插件, 这些插件可以读取、修改、添加抽象语法书中的任意元素
  有了编译器注解处理的标准 API 后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以使用插入式注解处理器在功能上有很大的发挥空间。
```

- 语义分析与字节码生成

``` doc
语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源代码抽象。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。
在Javac编译过程中，语法分析过程分为标注检查以及数据及控制流分析两个步骤，分别对应着 attribute() 和 flow () 方法完成

1) 标注检查
  标注检查步骤检查的内容包括诸如：变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。此外，这个过程中还有一个重要的步骤称为常量折叠。
  标注检查步骤在Javac源码中的实现类是 com.xun.tools.javac.comp.Attr 和com.sun.tools.javac.comp.Check 类。

2) 数据及控制流分析
  数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以查出诸如程序员局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译期的数据及控制流分析与类加载时的数据及数据流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或者运行期才能进行。
  如将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障，在 Javac 的源码中，数据及控制流分析的入口是 flow() 方法，具体操作由 com.sun.tools.javac.comp.Flow 类来完成。

3) 解语法糖
  语法糖是指在计算机语言中添加某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。
  Java是一种“低糖语言”，常用的语法糖主要是之前提到的泛型、变长参数、自动装箱/拆箱等。虚拟机运行时不支持这些语法，它们在编译期还原回简单的基础语法结构，这个过程称为解语法糖。解语法糖的过程是由desuger()方法触发的。

4) 字节码生成
  字节码生成是 Javac 编译过程的最后一个阶段，由 com.sun.tools.javac.jvm,Gen 类来完成，字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化为字节码写入磁盘中，编译器还进行了少量代码添加和转换工作。
  完成对语法树的遍历与调整之后，就会把填充了所有所需信息的符号表交给 com.sun.tools.javac.jvm.ClassWriter 类，由这个类的 wrtieClass() 方法输出字节码，生成最终的 Class 文件。
```

### 2. Java 语法糖

- 泛型和类型擦除

``` doc
泛型是JDK1.5新增的特性，它的本质是参数化类型的应用，也就是说所操作的数据类型被指定为一个参数，这种参数类型可以用于类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。

与C#的泛型不一样的是，Java 的泛型只存在于程序源码中，在编译后的字节码文件中，就已经替换成原来的原生类型，也称为裸类型，并且在相应的地方插入了强制转型代码。因此，对于运行期的Java语言来说，ArrayList与ArrayList就是同一个类，所以泛型技术实际上是 Java 语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。故当 List 和 List 作为参数时，擦除使得两者的特征签名变得一模一样，有时可能导致拥有该两个方法参数的方法无法重载。值得注意的是：当出现上述的情况的时候，如果返回值不一样的话，该两个方法是可以存在于一个Class文件中的，总结一下，两个方法如果有相同的名称和特征签名，但返回值不同，那它们也是合法地，可以共存于一个Class文件中。

擦除法所谓的擦除，仅仅是对方的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。
```

- 自动装箱、拆箱与遍历循环

``` doc
自动装箱、拆箱在编译之后就被转换成了相应的包装和还原方法，如 Integer.valueOf() 与 Integer,intValue() 方法，而遍历循环则把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历类实现 Iterable 接口的原因。
包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱，以及它们 equals() 方法不处理数据转型的关系。
```

- 条件编译

``` doc
Java 语言使用条件为常量的 if 语句，此代码中的 if 语句不同于其他 Java 代码，它在编译阶段就会被运行，生成的字节码之中只包含条件正确的部分。

Java 语言中条件编译的实现，也是 Java 语言的一颗语法糖，根据布尔常量值的真假，编译器将会把分支中不成立的代码块消除掉，这是在解语法糖阶段实现的。

Java 语言中还有不少的其他语言糖，如内部类、枚举类、断言语句、对枚举和字符串的 switch 支持、try 语句中定义和关闭资源等等。
```

### 3. 插入式注解处理器


## 二. 晚期(运行期) 优化

对热点代码(Hot Spot Code) 进行编译, 编译成与本地平台相关的机器码, 这个过程称为即时编译器 JIT(Just In Time Compiler)

### 1. HotSpot VM 的 JIT 即时编译器

- 解释器与编译器

``` doc
HotSpot 同时包含了解释器和编译器.

解释器: 程序要迅速启动和执行, 解释器可以首先发挥作用, 省去编译时间, 立即执行.

编译器: 程序运行一段时间后, 可以把热点方法和代码块编译成与平台相关的本地代码. HotSpot VM 内置了两个即时编译器
  Client Compiler (C1编译器)
  Server Compiler (C2编译器, 也叫 Opto 编译器)

  可以通过 -client、-server 参数强制指定虚拟机运行在 Client 模式或 Server 模式
```

- 编译对象与触发条件

``` doc

```

- 编译过程

``` doc

```

- 查看、分析即时编译结果

``` doc

```

### 2. 编译优化技术

- 优化技术概览

- 公共子表达式消除

- 数组边界检查消除

- 方法内联

- 逃逸分析
